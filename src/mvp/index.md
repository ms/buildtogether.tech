---
title: "A Minimum Viable Project"
lede: "How to start every new project"
template: page
---

-   Some things are the same for every project
-   Show the Python version with some notes about JavaScript

## Create repository on GitHub

-   Do this under a personal account, but for a real project would do it under an organizational account
-    Chose a name that wasn't already taken on [PyPI][pypi]
    -   Because we want to create a package in future
    -   All the good names are taken, so I chose the name of a small town near where I grew up
-   Made it public
-   Added the following:
    -   `README.md` (this file) is normally a description of the project, but we'll use it for note-taking
    -   `.gitignore` (selected from pulldown) to tell Git not to track ephemeral files generated by Python projects
    -   [MIT license][mit-license] (which GitHub puts in `LICENSE` rather than `LICENSE.md` - rename it)

## Add the files every project should have

-   Write these notes
-   Rename `LICENSE` to `LICENSE.md` (because file extensions are good)
-   Add `*~` to the `.gitignore` (for Emacs users)
-   Commit changes with a message that follows [conventional commits][conventional-commits]:

```
feat: describing steps so far and cleaning up default files

-   Rename `LICENSE` to show it's a Markdown file
-   Add notes to `README.md` about steps so far
-   Add Emacs backup files to `.gitignore
```

-   The subject line describes what kind of change it is (adding a feature)
    -   The body itemizes the changes
-   Push to GitHub

## Add Code of Conduct and contributors' guide

-   Used to add CoC by copying in a Markdown file, but [GitHub now supports this directly][gh-coc]
    -   Note: use `[text][key]` links in the body of my Markdown files and `[key]: url` in the foot
-   Follow GitHub's instructions to add CoC
    -   Call the branch `feat/code-of-conduct` (colons don't play nicely in Git branch names)
-   Copy in `CONTRIBUTING.md` from an existing project and edit
    -   Rename/add tags in GitHub to match descriptions in `CONTRIBUTING.md` (because GitHub's defaults aren't sensible)
-   *Don't* add a `GOVERNANCE.md` file explaining how decisions are made and who gets to make them
    -   But will as soon as the project attracts other people
-   Note: if you and your team are creating a lot of projects, consider using [Cookiecutter][cookiecutter] to keep them consistent

## Set up Python package

-   Create `mesachie` directory to contain package code
    -   Standard Python package structure to keep package code separate from support code
-   Add `mesachie/__init__.py`:

```python
"""Mesachie: a data analysis software project in Python."""

__version__ = "0.1.0"
__author__ = "Greg Wilson"
```

-   The existence of `__init__.py` signals that this directory is an importable module
        -   It can even be empty
    -   First line is a documentation string (docstring) explaining the file's purpose
    -   The `__version__` and `__author__` variables are recognized by Python's packaging tools
-   Create `tests` directory *beside* the `mesachie` package directory to contain tests
    -   And create `tests/__init__.py` to keep testing tools happy

```python
"""Make tests look like a module so actual module will load."""
```

-   Create a [conda][conda] virtual environment to avoid conflicts between packages installed for different projects
    -   Note: some people prefer [Docker][docker] for isolating environments...
    -   ...and because it's what we'll eventually use when we run in the cloud

```bash
$ conda create -n mesachie python=3.9
# say 'y' to the prompt
$ conda activate mesachie
```

-   Install [pytest][pytest] to run tests:
    -   Can (should) use `conda install` instead, but `pip` is simpler for small projects

```bash
$ pip install pytest
```

-   Create `requirements.txt` to make package installation reproducible
    -   What version did we get?

```bash
$ conda list pytest
#> pytest        7.1.1
```

-   Name uses three-part [semantic versioning][semver] to identify major version, minor version, and patch
-   Create `requirements.txt` file with major and minor version

```
pytest>=7.1
```

-   Create a "heartbeat" test in `tests/test_heartbeat.py` to make sure we can load our module

```python
"""Check that the project has a heartbeat."""

import mesachie


def test_module_can_be_imported():
    pass
```

-   Names of test files and functions must started with `test_` so that `pytest` can find them
    -   Don't use docstrings for tests: give them long informative names
    -   This test doesn't check anything (`pass`), but `pytest` will complain if `mesachie` cannot be imported
-   Run the test:

```bash
$ pytest
#> collected 1 item
#> tests/test_heartbeat.py .  
```

-   Add to these notes, commit, and push

## Automation

-   Want to make common commands re-runnable
    -   More trustworthy than documentation
-   Used to use [Make][make] to do this, but it's showing its age
    -   And its syntax is unpleasant
-   Use [Invoke][invoke] instead
-   `pip install invoke` and then add `invoke>=1.7` to `requirements.txt
-   Create a file in the project's root directory called `tasks.py`:

```python
"""Run common tasks."""

from invoke import task


@task
def list(c):
    """List available tasks."""
    c.run("inv --list")


@task
def test(c):
    """Run tests."""
    c.run("pytest")
```

-   The `@task` decorator identifies functions that can be run as tasks
    -   They can do any other processing (but we don't need them to yet)
-   The `c` parameter is a context that has details about the run
    -   We don't need that yet either
-   Run `inv list`:

```
Available tasks:

  list   List available tasks
  test   Run tests
```

-   We need to set up a [% g linter "linter" %] to check code quality
-   And [% g ci "continuous integration" %] to make sure it runs
-   But we need some useful code first
